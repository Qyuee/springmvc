### 예제코드 중에 static final을 사용하는데 그 이유와 의미는 무엇일까?
- static의 의미
    - static으로 선언된 변수는 메모리 공간에 하나만 존재한다.
    - 어디에서나 접근이 가능한 변수이다. 하지만 접근지정자가 public일 경우에만.
    
- 사용하는 이유는?
    - 인스턴스간에 데이터 공유가 필요한 상황에서 선언한다.
    - 인스턴스 변수는 하나의 클래스에서 생성되었더라도 각기다른 값을 가지지만, 클래스변수(static 멤버변수)는 인스턴스에 관계 없이 같은 값을 가진다.
    - 즉, static 변수는 모든 인스턴스가 공유하게된다.
    
- 우리의 예제에서 HashMap을 임시적인 메모리 저장소로 사용한다.
    - 이 때, 이 저장소로 사용되는 HashMap은 여러 동작에서 공유되어야 한다.
    - 그러므로 static하게하여 공유 될 수 있도록 한다.
    

### 멀티쓰레드 환경에서의 HashMap 동시성 이슈
- 여러 쓰레드가 동일한 자원에 접근할 때, 상태가 변경되기 전의 데이터를 참조하게 되어 의도치 않은 상태의 데이터를 참조하게 됨
- ex) 게시물의 카운트 수 증가
```
동시성 이슈가 발생하는 경우
1) 게시물의 count 수 조회
2) 게시물의 count 수를 1 증가 시킨다.

'쓰레드1'이 먼저 현재 count가 100인 것을 확인한다.
이 때, 거의 동시에 '쓰레드2'가 동일하게 count를 조회한다.

'쓰레드1'은 현재 조회 수가 100인 것을 확인 하였으니 +1하여 결과로써 현재 조회 수를 101로 업데이트 한다.
'쓰레드2' 또한 현재 조회수를 100으로 조회하였으니, +1하여 현재 조회수를 101으로 업데이트 한다.

>> 결과적으로 조회 수를 +1하는 동작은 2번 수행되었으나, 1번만 실행된 것과 같은 의도치 않은 상태가 보여진다.  
```

- 이러한 `동시성 이슈`를 해결하는 방법은 여러 방법이 있다.
  - 암시적 Lock : synchronized 키워드를 사용하여 한번에 하나의 쓰레드만 접근하여 데이터를 사용하도록 한다. 하지만 병렬성이 저하된다.
  - 메서드 Lock
  - 변수 Lock
  - 명시적 Lock

- 쓰레드 안전한 객체 사용
  - Concurrent 패키지: ConcurrentHashMap도 여기에 포함됨
  
  
### 생성자 주입 관련
@RequiredArgsConstructor (롬복의 어노테이션)
- final이 붙은 필드에 대한 생성자를 만들어준다.
```
@RequiredArgsConstructor
public class ... {
  private final TestClass instance;
  
  /*
  생성자 -> 없어도 롬복이 class 파일 구성 시, 코드를 넣어줄것임
  public ... (TestClass instance) {
    this.instance = instance;
  }
  */
}
```
